PATCH-P0-FIX-UPSTREAM: Fix unclean prototype declarations
BUGS: bnc#860137

Maintainer: Roman Drahtmueller <draht@suse.de>


diff -rNU 100 ../mariadb-10.0.10-o/include/my_dbug.h ./include/my_dbug.h
--- ../mariadb-10.0.10-o/include/my_dbug.h	2014-03-30 19:56:34.000000000 +0200
+++ ./include/my_dbug.h	2014-04-23 14:23:19.000000000 +0200
@@ -1,187 +1,187 @@
 /* Copyright (c) 2000, 2010, Oracle and/or its affiliates. 
    Copyright (C) 2000-2011 Monty Program Ab
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; version 2 of the License.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
 #ifndef _my_dbug_h
 #define _my_dbug_h
 
 #ifndef __WIN__
 #include <signal.h>
 #endif  /* not __WIN__ */
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 #if !defined(DBUG_OFF) && !defined(_lint)
 
 struct _db_stack_frame_ {
   const char *func;      /* function name of the previous stack frame       */
   const char *file;      /* filename of the function of previous frame      */
   uint level;            /* this nesting level, highest bit enables tracing */
   struct _db_stack_frame_ *prev; /* pointer to the previous frame */
 };
 
 struct  _db_code_state_;
 extern  my_bool _dbug_on_;
 extern  my_bool _db_keyword_(struct _db_code_state_ *, const char *, int);
 extern  int _db_explain_(struct _db_code_state_ *cs, char *buf, size_t len);
 extern  int _db_explain_init_(char *buf, size_t len);
 extern	int _db_is_pushed_(void);
 extern  void _db_setjmp_(void);
 extern  void _db_longjmp_(void);
 extern  void _db_process_(const char *name);
 extern  void _db_push_(const char *control);
 extern  void _db_pop_(void);
 extern  void _db_set_(const char *control);
 extern  void _db_set_init_(const char *control);
 extern void _db_enter_(const char *_func_, const char *_file_, uint _line_,
                        struct _db_stack_frame_ *_stack_frame_);
 extern  void _db_return_(uint _line_, struct _db_stack_frame_ *_stack_frame_);
 extern  void _db_pargs_(uint _line_,const char *keyword);
 extern  void _db_doprnt_(const char *format,...)
   ATTRIBUTE_FORMAT(printf, 1, 2);
 extern  void _db_dump_(uint _line_,const char *keyword,
                        const unsigned char *memory, size_t length);
 extern  void _db_end_(void);
 extern  void _db_lock_file_(void);
 extern  void _db_unlock_file_(void);
 extern  FILE *_db_fp_(void);
-extern  void _db_flush_();
+extern  void _db_flush_(void);
 extern void dbug_swap_code_state(void **code_state_store);
 extern void dbug_free_code_state(void **code_state_store);
 extern  const char* _db_get_func_(void);
 
 #define DBUG_ENTER(a) struct _db_stack_frame_ _db_stack_frame_; \
         _db_enter_ (a,__FILE__,__LINE__,&_db_stack_frame_)
 #define DBUG_LEAVE _db_return_ (__LINE__, &_db_stack_frame_)
 
 #define DBUG_RETURN(a1) do {DBUG_LEAVE; return(a1);} while(0)
 #define DBUG_VOID_RETURN do {DBUG_LEAVE; return;} while(0)
 #define DBUG_EXECUTE(keyword,a1) \
         do {if (_db_keyword_(0, (keyword), 0)) { a1 }} while(0)
 #define DBUG_EXECUTE_IF(keyword,a1) \
         do {if (_db_keyword_(0, (keyword), 1)) { a1 }} while(0)
 #define DBUG_EVALUATE(keyword,a1,a2) \
         (_db_keyword_(0,(keyword), 0) ? (a1) : (a2))
 #define DBUG_EVALUATE_IF(keyword,a1,a2) \
         (_db_keyword_(0,(keyword), 1) ? (a1) : (a2))
 #define DBUG_PRINT(keyword,arglist) \
         do {_db_pargs_(__LINE__,keyword); _db_doprnt_ arglist;} while(0)
 #define DBUG_PUSH(a1) _db_push_ (a1)
 #define DBUG_POP() _db_pop_ ()
 #define DBUG_SET(a1) _db_set_ (a1)
 #define DBUG_SET_INITIAL(a1) _db_set_init_ (a1)
 #define DBUG_PROCESS(a1) _db_process_(a1)
 #define DBUG_FILE _db_fp_()
 #define DBUG_DUMP(keyword,a1,a2) _db_dump_(__LINE__,keyword,a1,a2)
 #define DBUG_END()  _db_end_ ()
 #define DBUG_LOCK_FILE _db_lock_file_()
 #define DBUG_UNLOCK_FILE _db_unlock_file_()
 #define DBUG_ASSERT(A) assert(A)
 #define DBUG_EXPLAIN(buf,len) _db_explain_(0, (buf),(len))
 #define DBUG_EXPLAIN_INITIAL(buf,len) _db_explain_init_((buf),(len))
 #define DEBUGGER_OFF                    do { _dbug_on_= 0; } while(0)
 #define DEBUGGER_ON                     do { _dbug_on_= 1; } while(0)
 #define IF_DBUG(A,B)                    A
 #define DBUG_SWAP_CODE_STATE(arg) dbug_swap_code_state(arg)
 #define DBUG_FREE_CODE_STATE(arg) dbug_free_code_state(arg)
 
 #ifndef __WIN__
 #define DBUG_ABORT()                    (_db_flush_(), abort())
 #else
 /*
   Avoid popup with abort/retry/ignore buttons. When BUG#31745 is fixed we can
   call abort() instead of _exit(3) (now it would cause a "test signal" popup).
 */
 #include <crtdbg.h>
 #define DBUG_ABORT() (_db_flush_(),\
                      (void)_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE),\
                      (void)_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR),\
                      _exit(3))
 #endif
 
 /*
   Make the program fail, without creating a core file.
   abort() will send SIGABRT which (most likely) generates core.
   Use SIGKILL instead, which cannot be caught.
   We also pause the current thread, until the signal is actually delivered.
   An alternative would be to use _exit(EXIT_FAILURE),
   but then valgrind would report lots of memory leaks.
  */
 #ifdef __WIN__
 #define DBUG_SUICIDE() DBUG_ABORT()
 #else
-extern void _db_suicide_();
+extern void _db_suicide_(void);
 #define DBUG_SUICIDE() (_db_flush_(), _db_suicide_())
 #endif
 
 #else                                           /* No debugger */
 
 #define DBUG_ENTER(a1)
 #define DBUG_VIOLATION_HELPER_LEAVE do { } while(0)
 #define DBUG_LEAVE
 #define DBUG_RETURN(a1)                 do { return(a1); } while(0)
 #define DBUG_VOID_RETURN                do { return; } while(0)
 #define DBUG_EXECUTE(keyword,a1)        do { } while(0)
 #define DBUG_EXECUTE_IF(keyword,a1)     do { } while(0)
 #define DBUG_EVALUATE(keyword,a1,a2) (a2)
 #define DBUG_EVALUATE_IF(keyword,a1,a2) (a2)
 #define DBUG_PRINT(keyword,arglist)     do { } while(0)
 #define DBUG_PUSH(a1)                   do { } while(0)
 #define DBUG_SET(a1)                    do { } while(0)
 #define DBUG_SET_INITIAL(a1)            do { } while(0)
 #define DBUG_POP()                      do { } while(0)
 #define DBUG_PROCESS(a1)                do { } while(0)
 #define DBUG_DUMP(keyword,a1,a2)        do { } while(0)
 #define DBUG_END()                      do { } while(0)
 #define DBUG_ASSERT(A)                  do { } while(0)
 #define DBUG_LOCK_FILE                  do { } while(0)
 #define DBUG_FILE (stderr)
 #define DBUG_UNLOCK_FILE                do { } while(0)
 #define DBUG_EXPLAIN(buf,len)
 #define DBUG_EXPLAIN_INITIAL(buf,len)
 #define DEBUGGER_OFF                    do { } while(0)
 #define DEBUGGER_ON                     do { } while(0)
 #define IF_DBUG(A,B)                    B
 #define DBUG_SWAP_CODE_STATE(arg)       do { } while(0)
 #define DBUG_FREE_CODE_STATE(arg)       do { } while(0)
 #define DBUG_ABORT()                    do { } while(0)
 #define DBUG_CRASH_ENTER(func)
 #define DBUG_CRASH_RETURN(val)          do { return(val); } while(0)
 #define DBUG_CRASH_VOID_RETURN          do { return; } while(0)
 #define DBUG_SUICIDE()                  do { } while(0)
 
 #endif
 
 #ifdef EXTRA_DEBUG
 /**
   Sync points allow us to force the server to reach a certain line of code
   and block there until the client tells the server it is ok to go on.
   The client tells the server to block with SELECT GET_LOCK()
   and unblocks it with SELECT RELEASE_LOCK(). Used for debugging difficult
   concurrency problems
 */
 #define DBUG_SYNC_POINT(lock_name,lock_timeout) \
  debug_sync_point(lock_name,lock_timeout)
 void debug_sync_point(const char* lock_name, uint lock_timeout);
 #else
 #define DBUG_SYNC_POINT(lock_name,lock_timeout)
 #endif /* EXTRA_DEBUG */
 
 #ifdef	__cplusplus
 }
 #endif
 
 #endif /* _my_dbug_h */
diff -rNU 100 ../mariadb-10.0.10-o/include/my_global.h ./include/my_global.h
--- ../mariadb-10.0.10-o/include/my_global.h	2014-03-30 19:56:37.000000000 +0200
+++ ./include/my_global.h	2014-04-23 14:23:46.000000000 +0200
@@ -458,201 +458,201 @@
 #endif
 
 /*
   Deprecated workaround for false-positive uninitialized variables
   warnings. Those should be silenced using tool-specific heuristics.
 
   Enabled by default for g++ due to the bug referenced below.
 */
 #if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \
     (defined(__GNUC__) && defined(__cplusplus))
 #define LINT_INIT(var) var= 0
 #else
 #define LINT_INIT(var)
 #endif
 
 #ifndef SO_EXT
 #ifdef _WIN32
 #define SO_EXT ".dll"
 #else
 #define SO_EXT ".so"
 #endif
 #endif
 
 /*
    Suppress uninitialized variable warning without generating code.
 
    The _cplusplus is a temporary workaround for C++ code pending a fix
    for a g++ bug (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34772).
 */
 #if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \
     defined(__cplusplus) || !defined(__GNUC__)
 #define UNINIT_VAR(x) x= 0
 #else
 /* GCC specific self-initialization which inhibits the warning. */
 #define UNINIT_VAR(x) x= x
 #endif
 
 #if !defined(HAVE_UINT)
 #undef HAVE_UINT
 #define HAVE_UINT
 typedef unsigned int uint;
 typedef unsigned short ushort;
 #endif
 
 #define swap_variables(t, a, b) do { t dummy; dummy= a; a= b; b= dummy; } while(0)
 #define MY_TEST(a) ((a) ? 1 : 0)
 #define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)
 #define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)
 #define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))
 #define test_all_bits(a,b) (((a) & (b)) == (b))
 #define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))
 
 /* Define some general constants */
 #ifndef TRUE
 #define TRUE		(1)	/* Logical true */
 #define FALSE		(0)	/* Logical false */
 #endif
 
 #include <my_compiler.h>
 
 /*
   Wen using the embedded library, users might run into link problems,
   duplicate declaration of __cxa_pure_virtual, solved by declaring it a
   weak symbol.
 */
 #if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)
 C_MODE_START
 int __cxa_pure_virtual () __attribute__ ((weak));
 C_MODE_END
 #endif
 
 /* The DBUG_ON flag always takes precedence over default DBUG_OFF */
 #if defined(DBUG_ON) && defined(DBUG_OFF)
 #undef DBUG_OFF
 #endif
 
 /* We might be forced to turn debug off, if not turned off already */
 #if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)
 #  define DBUG_OFF
 #  ifdef DBUG_ON
 #    undef DBUG_ON
 #  endif
 #endif
 
 #ifdef DBUG_OFF
 #undef EXTRA_DEBUG
 #endif
 
 /* Some types that is different between systems */
 
 typedef int	File;		/* File descriptor */
 #ifdef _WIN32
 typedef SOCKET my_socket;
 #else
 typedef int	my_socket;	/* File descriptor for sockets */
 #define INVALID_SOCKET -1
 #endif
 /* Type for fuctions that handles signals */
 #define sig_handler RETSIGTYPE
 C_MODE_START
-typedef void	(*sig_return)();/* Returns type from signal */
+typedef void	(*sig_return)(void);/* Returns type from signal */
 C_MODE_END
 #if defined(__GNUC__) && !defined(_lint)
 typedef char	pchar;		/* Mixed prototypes can take char */
 typedef char	puchar;		/* Mixed prototypes can take char */
 typedef char	pbool;		/* Mixed prototypes can take char */
 typedef short	pshort;		/* Mixed prototypes can take short int */
 typedef float	pfloat;		/* Mixed prototypes can take float */
 #else
 typedef int	pchar;		/* Mixed prototypes can't take char */
 typedef uint	puchar;		/* Mixed prototypes can't take char */
 typedef int	pbool;		/* Mixed prototypes can't take char */
 typedef int	pshort;		/* Mixed prototypes can't take short int */
 typedef double	pfloat;		/* Mixed prototypes can't take float */
 #endif
 C_MODE_START
 typedef int	(*qsort_cmp)(const void *,const void *);
 typedef int	(*qsort_cmp2)(void*, const void *,const void *);
 C_MODE_END
 #define qsort_t RETQSORTTYPE	/* Broken GCC cant handle typedef !!!! */
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 typedef SOCKET_SIZE_TYPE size_socket;
 
 #ifndef SOCKOPT_OPTLEN_TYPE
 #define SOCKOPT_OPTLEN_TYPE size_socket
 #endif
 
 /* file create flags */
 
 #ifndef O_SHARE			/* Probably not windows */
 #define O_SHARE		0	/* Flag to my_open for shared files */
 #ifndef O_BINARY
 #define O_BINARY	0	/* Flag to my_open for binary files */
 #endif
 #ifndef FILE_BINARY
 #define FILE_BINARY	O_BINARY /* Flag to my_fopen for binary streams */
 #endif
 #ifdef HAVE_FCNTL
 #define HAVE_FCNTL_LOCK
 #define F_TO_EOF	0L	/* Param to lockf() to lock rest of file */
 #endif
 #endif /* O_SHARE */
 
 #ifndef O_TEMPORARY
 #define O_TEMPORARY	0
 #endif
 #ifndef O_SHORT_LIVED
 #define O_SHORT_LIVED	0
 #endif
 #ifndef O_NOFOLLOW
 #define O_NOFOLLOW      0
 #endif
 
 /* additional file share flags for win32 */
 #ifdef __WIN__
 #define _SH_DENYRWD     0x110    /* deny read/write mode & delete */
 #define _SH_DENYWRD     0x120    /* deny write mode & delete      */
 #define _SH_DENYRDD     0x130    /* deny read mode & delete       */
 #define _SH_DENYDEL     0x140    /* deny delete only              */
 #endif /* __WIN__ */
 
 
 /* General constants */
 #define FN_LEN		256	/* Max file name len */
 #define FN_HEADLEN	253	/* Max length of filepart of file name */
 #define FN_EXTLEN	20	/* Max length of extension (part of FN_LEN) */
 #define FN_REFLEN	512	/* Max length of full path-name */
 #define FN_EXTCHAR	'.'
 #define FN_HOMELIB	'~'	/* ~/ is used as abbrev for home dir */
 #define FN_CURLIB	'.'	/* ./ is used as abbrev for current dir */
 #define FN_PARENTDIR	".."	/* Parent directory; Must be a string */
 
 #ifdef _WIN32
 #define FN_LIBCHAR	'\\'
 #define FN_LIBCHAR2	'/'
 #define FN_DIRSEP       "/\\"               /* Valid directory separators */
 #define FN_EXEEXT   ".exe"
 #define FN_SOEXT    ".dll"
 #define FN_ROOTDIR	"\\"
 #define FN_DEVCHAR	':'
 #define FN_NETWORK_DRIVES	/* Uses \\ to indicate network drives */
 #define FN_NO_CASE_SENCE	/* Files are not case-sensitive */
 #else
 #define FN_LIBCHAR	'/'
 #define FN_LIBCHAR2	'/'
 #define FN_DIRSEP       "/"     /* Valid directory separators */
 #define FN_EXEEXT   ""
 #define FN_SOEXT    ".so"
 #define FN_ROOTDIR	"/"
 #endif
 
 /* 
   MY_FILE_MIN is  Windows speciality and is used to quickly detect
   the mismatch of CRT and mysys file IO usage on Windows at runtime.
   CRT file descriptors can be in the range 0-2047, whereas descriptors returned
   by my_open() will start with 2048. If a file descriptor with value less then
   MY_FILE_MIN is passed to mysys IO function, chances are it stemms from
   open()/fileno() and not my_open()/my_fileno.
 
diff -rNU 100 ../mariadb-10.0.10-o/include/my_pthread.h ./include/my_pthread.h
--- ../mariadb-10.0.10-o/include/my_pthread.h	2014-03-30 19:56:37.000000000 +0200
+++ ./include/my_pthread.h	2014-04-23 14:24:59.000000000 +0200
@@ -594,247 +594,247 @@
   };
 
   /*
     Portable implementation (is_srwlock == FALSE)
     Fields are identical with Unix my_rw_lock_t fields.
   */
   struct 
   {
     pthread_mutex_t lock;       /* lock for structure		*/
     pthread_cond_t  readers;    /* waiting readers		*/
     pthread_cond_t  writers;    /* waiting writers		*/
     int state;                  /* -1:writer,0:free,>0:readers	*/
     int waiters;                /* number of waiting writers	*/
 #ifdef SAFE_MUTEX
     pthread_t  write_thread;
 #endif
   };
 } my_rw_lock_t;
 
 
 #else /* _WIN32 */
 
 /*
   On systems which don't support native read/write locks we have
   to use own implementation.
 */
 typedef struct st_my_rw_lock_t {
 	pthread_mutex_t lock;		/* lock for structure		*/
 	pthread_cond_t	readers;	/* waiting readers		*/
 	pthread_cond_t	writers;	/* waiting writers		*/
 	int		state;		/* -1:writer,0:free,>0:readers	*/
 	int             waiters;        /* number of waiting writers	*/
 #ifdef SAFE_MUTEX
         pthread_t       write_thread;
 #endif
 } my_rw_lock_t;
 
 #endif /*! _WIN32 */
 
 extern int my_rw_init(my_rw_lock_t *);
 extern int my_rw_destroy(my_rw_lock_t *);
 extern int my_rw_rdlock(my_rw_lock_t *);
 extern int my_rw_wrlock(my_rw_lock_t *);
 extern int my_rw_unlock(my_rw_lock_t *);
 extern int my_rw_tryrdlock(my_rw_lock_t *);
 extern int my_rw_trywrlock(my_rw_lock_t *);
 #ifdef SAFE_MUTEX
 #define my_rw_lock_assert_write_owner(A) \
   DBUG_ASSERT((A)->state == -1 && pthread_equal(pthread_self(), \
                                                 (A)->write_thread))
 #define my_rw_lock_assert_not_write_owner(A) \
   DBUG_ASSERT((A)->state >= 0 || ! pthread_equal(pthread_self(), \
                                                  (A)->write_thread))
 #else
 #define my_rw_lock_assert_write_owner(A)
 #define my_rw_lock_assert_not_write_owner(A)
 #endif
 #endif /* NEED_MY_RW_LOCK */
 
 
 #define GETHOSTBYADDR_BUFF_SIZE 2048
 
 #ifndef HAVE_THR_SETCONCURRENCY
 #define thr_setconcurrency(A) pthread_dummy(0)
 #endif
 #if !defined(HAVE_PTHREAD_ATTR_SETSTACKSIZE) && ! defined(pthread_attr_setstacksize)
 #define pthread_attr_setstacksize(A,B) pthread_dummy(0)
 #endif
 
 /* Define mutex types, see my_thr_init.c */
 #define MY_MUTEX_INIT_SLOW   NULL
 #ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 extern pthread_mutexattr_t my_fast_mutexattr;
 #define MY_MUTEX_INIT_FAST &my_fast_mutexattr
 #else
 #define MY_MUTEX_INIT_FAST   NULL
 #endif
 #ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 extern pthread_mutexattr_t my_errorcheck_mutexattr;
 #define MY_MUTEX_INIT_ERRCHK &my_errorcheck_mutexattr
 #else
 #define MY_MUTEX_INIT_ERRCHK   NULL
 #endif
 
 #ifndef ESRCH
 /* Define it to something */
 #define ESRCH 1
 #endif
 
 typedef ulong my_thread_id;
 
 extern void my_threadattr_global_init(void);
 extern my_bool my_thread_global_init(void);
 extern void my_thread_global_reinit(void);
 extern void my_thread_global_end(void);
 extern my_bool my_thread_init(void);
 extern void my_thread_end(void);
 extern const char *my_thread_name(void);
 extern my_thread_id my_thread_dbug_id(void);
 extern int pthread_dummy(int);
-extern void my_mutex_init();
-extern void my_mutex_end();
+extern void my_mutex_init(void);
+extern void my_mutex_end(void);
 
 /* All thread specific variables are in the following struct */
 
 #define THREAD_NAME_SIZE 10
 #ifndef DEFAULT_THREAD_STACK
 /*
   We need to have at least 256K stack to handle calls to myisamchk_init()
   with the current number of keys and key parts.
 */
 #define DEFAULT_THREAD_STACK	(288*1024L)
 #endif
 
 #define MY_PTHREAD_LOCK_READ 0
 #define MY_PTHREAD_LOCK_WRITE 1
 
 #include <mysql/psi/mysql_thread.h>
 
 #define INSTRUMENT_ME 0
 
 struct st_my_thread_var
 {
   int thr_errno;
   mysql_cond_t suspend;
   mysql_mutex_t mutex;
   mysql_mutex_t * volatile current_mutex;
   mysql_cond_t * volatile current_cond;
   pthread_t pthread_self;
   my_thread_id id;
   int cmp_length;
   int volatile abort;
   my_bool init;
   struct st_my_thread_var *next,**prev;
   void *opt_info;
   uint  lock_type; /* used by conditional release the queue */
   void  *stack_ends_here;
   safe_mutex_t *mutex_in_use;
 #ifndef DBUG_OFF
   void *dbug;
   char name[THREAD_NAME_SIZE+1];
 #endif
 };
 
 extern struct st_my_thread_var *_my_thread_var(void) __attribute__ ((const));
-extern void **my_thread_var_dbug();
-extern safe_mutex_t **my_thread_var_mutex_in_use();
+extern void **my_thread_var_dbug(void);
+extern safe_mutex_t **my_thread_var_mutex_in_use(void);
 extern uint my_thread_end_wait_time;
 extern my_bool safe_mutex_deadlock_detector;
 #define my_thread_var (_my_thread_var())
 #define my_errno my_thread_var->thr_errno
 /*
   Keep track of shutdown,signal, and main threads so that my_end() will not
   report errors with them
 */
 
 /* Which kind of thread library is in use */
 
 #define THD_LIB_OTHER 1
 #define THD_LIB_NPTL  2
 #define THD_LIB_LT    4
 
 extern uint thd_lib_detected;
 
 /*
   thread_safe_xxx functions are for critical statistic or counters.
   The implementation is guaranteed to be thread safe, on all platforms.
   Note that the calling code should *not* assume the counter is protected
   by the mutex given, as the implementation of these helpers may change
   to use my_atomic operations instead.
 */
 
 #ifndef thread_safe_increment
 #ifdef _WIN32
 #define thread_safe_increment(V,L) InterlockedIncrement((long*) &(V))
 #define thread_safe_decrement(V,L) InterlockedDecrement((long*) &(V))
 #else
 #define thread_safe_increment(V,L) \
         (mysql_mutex_lock((L)), (V)++, mysql_mutex_unlock((L)))
 #define thread_safe_decrement(V,L) \
         (mysql_mutex_lock((L)), (V)--, mysql_mutex_unlock((L)))
 #endif
 #endif
 
 #ifndef thread_safe_add
 #ifdef _WIN32
 #define thread_safe_add(V,C,L) InterlockedExchangeAdd((long*) &(V),(C))
 #define thread_safe_sub(V,C,L) InterlockedExchangeAdd((long*) &(V),-(long) (C))
 #else
 #define thread_safe_add(V,C,L) \
         (mysql_mutex_lock((L)), (V)+=(C), mysql_mutex_unlock((L)))
 #define thread_safe_sub(V,C,L) \
         (mysql_mutex_lock((L)), (V)-=(C), mysql_mutex_unlock((L)))
 #endif
 #endif
 
 
 /*
   statistics_xxx functions are for non critical statistic,
   maintained in global variables.
   When compiling with SAFE_STATISTICS:
   - race conditions can not occur.
   - some locking occurs, which may cause performance degradation.
 
   When compiling without SAFE_STATISTICS:
   - race conditions can occur, making the result slightly inaccurate.
   - the lock given is not honored.
 */
 #ifdef SAFE_STATISTICS
 #define statistic_increment(V,L) thread_safe_increment((V),(L))
 #define statistic_decrement(V,L) thread_safe_decrement((V),(L))
 #define statistic_add(V,C,L)     thread_safe_add((V),(C),(L))
 #define statistic_sub(V,C,L)     thread_safe_sub((V),(C),(L))
 #else
 #define statistic_decrement(V,L) (V)--
 #define statistic_increment(V,L) (V)++
 #define statistic_add(V,C,L)     (V)+=(C)
 #define statistic_sub(V,C,L)     (V)-=(C)
 #endif /* SAFE_STATISTICS */
 
 /*
   No locking needed, the counter is owned by the thread
 */
 #define status_var_increment(V) (V)++
 #define status_var_decrement(V) (V)--
 #define status_var_add(V,C)     (V)+=(C)
 #define status_var_sub(V,C)     (V)-=(C)
 
 #ifdef SAFE_MUTEX
 #define mysql_mutex_record_order(A,B)                   \
   do {                                                  \
     mysql_mutex_lock(A); mysql_mutex_lock(B);           \
     mysql_mutex_unlock(B); mysql_mutex_unlock(A);       \
   }  while(0)
 #else
 #define mysql_mutex_record_order(A,B) do { } while(0) 
 #endif
 
 /* At least Windows and NetBSD do not have this definition */
 #ifndef PTHREAD_STACK_MIN
 #define PTHREAD_STACK_MIN 65536
 #endif
 
 #ifdef  __cplusplus
 }
 #endif
 #endif /* _my_ptread_h */
diff -rNU 100 ../mariadb-10.0.10-o/include/my_sys.h ./include/my_sys.h
--- ../mariadb-10.0.10-o/include/my_sys.h	2014-03-30 19:56:37.000000000 +0200
+++ ./include/my_sys.h	2014-04-23 14:26:50.000000000 +0200
@@ -539,226 +539,226 @@
    (_my_b_write(info,0,0) , ((*(info)->write_pos++)=(chr))))
 
 #define my_b_fill_cache(info) \
   (((info)->read_end=(info)->read_pos),(*(info)->read_function)(info,0,0))
 
 #define my_b_tell(info) ((info)->pos_in_file + \
 			 (size_t) (*(info)->current_pos - (info)->request_pos))
 #define my_b_write_tell(info) ((info)->pos_in_file + \
 			 ((info)->write_pos - (info)->write_buffer))
 
 #define my_b_get_buffer_start(info) (info)->request_pos 
 #define my_b_get_bytes_in_buffer(info) (char*) (info)->read_end -   \
   (char*) my_b_get_buffer_start(info)
 #define my_b_get_pos_in_file(info) (info)->pos_in_file
 
 /* tell write offset in the SEQ_APPEND cache */
 int      my_b_copy_to_file(IO_CACHE *cache, FILE *file);
 my_off_t my_b_append_tell(IO_CACHE* info);
 my_off_t my_b_safe_tell(IO_CACHE* info); /* picks the correct tell() */
 
 #define my_b_bytes_in_cache(info) (size_t) (*(info)->current_end - \
 					  *(info)->current_pos)
 
 typedef uint32 ha_checksum;
 extern ulong my_crc_dbug_check;
 
 #include <my_alloc.h>
 
 	/* Prototypes for mysys and my_func functions */
 
 extern int my_copy(const char *from,const char *to,myf MyFlags);
 extern int my_delete(const char *name,myf MyFlags);
 extern int my_getwd(char * buf,size_t size,myf MyFlags);
 extern int my_setwd(const char *dir,myf MyFlags);
 extern int my_lock(File fd,int op,my_off_t start, my_off_t length,myf MyFlags);
 extern void *my_once_alloc(size_t Size,myf MyFlags);
 extern void my_once_free(void);
 extern char *my_once_strdup(const char *src,myf myflags);
 extern void *my_once_memdup(const void *src, size_t len, myf myflags);
 extern File my_open(const char *FileName,int Flags,myf MyFlags);
 extern File my_register_filename(File fd, const char *FileName,
 				 enum file_type type_of_file,
 				 uint error_message_number, myf MyFlags);
 extern File my_create(const char *FileName,int CreateFlags,
 		      int AccessFlags, myf MyFlags);
 extern int my_close(File Filedes,myf MyFlags);
 extern int my_mkdir(const char *dir, int Flags, myf MyFlags);
 extern int my_readlink(char *to, const char *filename, myf MyFlags);
 extern int my_is_symlink(const char *filename);
 extern int my_realpath(char *to, const char *filename, myf MyFlags);
 extern File my_create_with_symlink(const char *linkname, const char *filename,
 				   int createflags, int access_flags,
 				   myf MyFlags);
 extern int my_delete_with_symlink(const char *name, myf MyFlags);
 extern int my_rename_with_symlink(const char *from,const char *to,myf MyFlags);
 extern int my_symlink(const char *content, const char *linkname, myf MyFlags);
 extern size_t my_read(File Filedes,uchar *Buffer,size_t Count,myf MyFlags);
 extern size_t my_pread(File Filedes,uchar *Buffer,size_t Count,my_off_t offset,
 		     myf MyFlags);
 extern int my_rename(const char *from,const char *to,myf MyFlags);
 extern my_off_t my_seek(File fd,my_off_t pos,int whence,myf MyFlags);
 extern my_off_t my_tell(File fd,myf MyFlags);
 extern size_t my_write(File Filedes,const uchar *Buffer,size_t Count,
 		     myf MyFlags);
 extern size_t my_pwrite(File Filedes,const uchar *Buffer,size_t Count,
 		      my_off_t offset,myf MyFlags);
 extern size_t my_fread(FILE *stream,uchar *Buffer,size_t Count,myf MyFlags);
 extern size_t my_fwrite(FILE *stream,const uchar *Buffer,size_t Count,
 		      myf MyFlags);
 extern my_off_t my_fseek(FILE *stream,my_off_t pos,int whence,myf MyFlags);
 extern my_off_t my_ftell(FILE *stream,myf MyFlags);
 
 /* implemented in my_memmem.c */
 extern void *my_memmem(const void *haystack, size_t haystacklen,
                        const void *needle, size_t needlelen);
 
 
 #ifdef _WIN32
 extern int      my_access(const char *path, int amode);
 #else
 #define my_access access
 #endif
 
 extern int check_if_legal_filename(const char *path);
 extern int check_if_legal_tablename(const char *path);
 
 #ifdef __WIN__
 extern my_bool is_filename_allowed(const char *name, size_t length,
                    my_bool allow_current_dir);
 #else /* __WIN__ */
 # define is_filename_allowed(name, length, allow_cwd) (TRUE)
 #endif /* __WIN__ */ 
 
 #ifdef _WIN32
 /* Windows-only functions (CRT equivalents)*/
 extern HANDLE   my_get_osfhandle(File fd);
 extern void     my_osmaperr(unsigned long last_error);
 #endif
 
 extern void init_glob_errs(void);
-extern const char** get_global_errmsgs();
+extern const char** get_global_errmsgs(void);
 extern void wait_for_free_space(const char *filename, int errors);
 extern FILE *my_fopen(const char *FileName,int Flags,myf MyFlags);
 extern FILE *my_fdopen(File Filedes,const char *name, int Flags,myf MyFlags);
 extern FILE *my_freopen(const char *path, const char *mode, FILE *stream);
 extern int my_fclose(FILE *fd,myf MyFlags);
 extern int my_vfprintf(FILE *stream, const char* format, va_list args);
 extern void my_strerror(char *buf, size_t len, int nr);
 extern int my_fprintf(FILE *stream, const char* format, ...);
 extern File my_fileno(FILE *fd);
 extern int my_chsize(File fd,my_off_t newlength, int filler, myf MyFlags);
 extern int my_chmod(const char *name, mode_t mode, myf my_flags);
 extern const char *my_basename(const char *filename);
 extern void thr_set_sync_wait_callback(void (*before_sync)(void),
                                        void (*after_sync)(void));
 extern int my_sync(File fd, myf my_flags);
 extern int my_sync_dir(const char *dir_name, myf my_flags);
 extern int my_sync_dir_by_file(const char *file_name, myf my_flags);
 extern const char *my_get_err_msg(uint nr);
 extern void my_error(uint nr,myf MyFlags, ...);
 extern void my_printf_error(uint my_err, const char *format,
                             myf MyFlags, ...)
                             ATTRIBUTE_FORMAT(printf, 2, 4);
 extern void my_printv_error(uint error, const char *format, myf MyFlags,
                             va_list ap);
-extern int my_error_register(const char** (*get_errmsgs) (),
+extern int my_error_register(const char** (*get_errmsgs) (void),
                              uint first, uint last);
 extern const char **my_error_unregister(uint first, uint last);
 extern void my_message(uint my_err, const char *str,myf MyFlags);
 extern void my_message_stderr(uint my_err, const char *str, myf MyFlags);
 extern my_bool my_init(void);
 extern void my_end(int infoflag);
 extern int my_redel(const char *from, const char *to, time_t backup_time_stamp,
                     myf MyFlags);
 void my_create_backup_name(char *to, const char *from,
                            time_t backup_time_stamp);
 extern int my_copystat(const char *from, const char *to, int MyFlags);
 extern char * my_filename(File fd);
 
 #ifdef EXTRA_DEBUG
 void my_print_open_files(void);
 #else
 #define my_print_open_files()
 #endif
 
 extern my_bool init_tmpdir(MY_TMPDIR *tmpdir, const char *pathlist);
 extern char *my_tmpdir(MY_TMPDIR *tmpdir);
 extern void free_tmpdir(MY_TMPDIR *tmpdir);
 
 extern void my_remember_signal(int signal_number,sig_handler (*func)(int));
 extern size_t dirname_part(char * to,const char *name, size_t *to_res_length);
 extern size_t dirname_length(const char *name);
 #define base_name(A) (A+dirname_length(A))
 extern int test_if_hard_path(const char *dir_name);
 extern my_bool has_path(const char *name);
 extern char *convert_dirname(char *to, const char *from, const char *from_end);
 extern void to_unix_path(char * name);
 extern char * fn_ext(const char *name);
 extern char * fn_ext2(const char *name);
 extern char * fn_same(char * toname,const char *name,int flag);
 extern char * fn_format(char * to,const char *name,const char *dir,
 			   const char *form, uint flag);
 extern size_t strlength(const char *str);
 extern void pack_dirname(char * to,const char *from);
 extern size_t normalize_dirname(char * to, const char *from);
 extern size_t unpack_dirname(char * to,const char *from);
 extern size_t cleanup_dirname(char * to,const char *from);
 extern size_t system_filename(char * to,const char *from);
 extern size_t unpack_filename(char * to,const char *from);
 extern char * intern_filename(char * to,const char *from);
 extern int pack_filename(char * to, const char *name, size_t max_length);
 extern char * my_path(char * to,const char *progname,
 			 const char *own_pathname_part);
 extern char * my_load_path(char * to, const char *path,
 			      const char *own_path_prefix);
 extern int wild_compare(const char *str,const char *wildstr,
                         pbool str_is_pattern);
 extern my_bool array_append_string_unique(const char *str,
                                           const char **array, size_t size);
 extern void get_date(char * to,int timeflag,time_t use_time);
 extern void soundex(CHARSET_INFO *, char * out_pntr, char * in_pntr,
                     pbool remove_garbage);
 extern int init_record_cache(RECORD_CACHE *info,size_t cachesize,File file,
 			     size_t reclength,enum cache_type type,
 			     pbool use_async_io);
 extern int read_cache_record(RECORD_CACHE *info,uchar *to);
 extern int end_record_cache(RECORD_CACHE *info);
 extern int write_cache_record(RECORD_CACHE *info,my_off_t filepos,
 			      const uchar *record,size_t length);
 extern int flush_write_cache(RECORD_CACHE *info);
 extern void handle_recived_signals(void);
 
 extern sig_handler my_set_alarm_variable(int signo);
 extern my_bool radixsort_is_appliccable(uint n_items, size_t size_of_element);
 extern void my_string_ptr_sort(uchar *base,uint items,size_t size);
 extern void radixsort_for_str_ptr(uchar* base[], uint number_of_elements,
 				  size_t size_of_element,uchar *buffer[]);
 extern qsort_t my_qsort(void *base_ptr, size_t total_elems, size_t size,
                         qsort_cmp cmp);
 extern qsort_t my_qsort2(void *base_ptr, size_t total_elems, size_t size,
                          qsort2_cmp cmp, void *cmp_argument);
 extern qsort2_cmp get_ptr_compare(size_t);
 void my_store_ptr(uchar *buff, size_t pack_length, my_off_t pos);
 my_off_t my_get_ptr(uchar *ptr, size_t pack_length);
 extern int init_io_cache(IO_CACHE *info,File file,size_t cachesize,
 			 enum cache_type type,my_off_t seek_offset,
 			 pbool use_async_io, myf cache_myflags);
 extern my_bool reinit_io_cache(IO_CACHE *info,enum cache_type type,
 			       my_off_t seek_offset,pbool use_async_io,
 			       pbool clear_cache);
 extern void setup_io_cache(IO_CACHE* info);
 extern int _my_b_read(IO_CACHE *info,uchar *Buffer,size_t Count);
 extern int _my_b_read_r(IO_CACHE *info,uchar *Buffer,size_t Count);
 extern void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,
                                 IO_CACHE *write_cache, uint num_threads);
 extern void remove_io_thread(IO_CACHE *info);
 extern int _my_b_seq_read(IO_CACHE *info,uchar *Buffer,size_t Count);
 extern int _my_b_net_read(IO_CACHE *info,uchar *Buffer,size_t Count);
 extern int _my_b_get(IO_CACHE *info);
 extern int _my_b_async_read(IO_CACHE *info,uchar *Buffer,size_t Count);
 extern int _my_b_write(IO_CACHE *info,const uchar *Buffer,size_t Count);
 extern int my_b_append(IO_CACHE *info,const uchar *Buffer,size_t Count);
 extern int my_b_safe_write(IO_CACHE *info,const uchar *Buffer,size_t Count);
 
 extern int my_block_write(IO_CACHE *info, const uchar *Buffer,
 			  size_t Count, my_off_t pos);
@@ -782,235 +782,235 @@
 extern void close_cached_file(IO_CACHE *cache);
 File create_temp_file(char *to, const char *dir, const char *pfx,
 		      int mode, myf MyFlags);
 #define my_init_dynamic_array(A,B,C,D,E) init_dynamic_array2(A,B,NULL,C,D,E)
 #define my_init_dynamic_array2(A,B,C,D,E,F) init_dynamic_array2(A,B,C,D,E,F)
 extern my_bool init_dynamic_array2(DYNAMIC_ARRAY *array, uint element_size,
                                    void *init_buffer, uint init_alloc,
                                    uint alloc_increment, myf my_flags);
 extern my_bool insert_dynamic(DYNAMIC_ARRAY *array, const void* element);
 extern void *alloc_dynamic(DYNAMIC_ARRAY *array);
 extern void *pop_dynamic(DYNAMIC_ARRAY*);
 extern my_bool set_dynamic(DYNAMIC_ARRAY *array, const void *element,
                            uint array_index);
 extern my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements);
 extern void get_dynamic(DYNAMIC_ARRAY *array, void *element, uint array_index);
 extern void delete_dynamic(DYNAMIC_ARRAY *array);
 extern void delete_dynamic_element(DYNAMIC_ARRAY *array, uint array_index);
 extern void delete_dynamic_with_callback(DYNAMIC_ARRAY *array, FREE_FUNC f);
 extern void freeze_size(DYNAMIC_ARRAY *array);
 extern int  get_index_dynamic(DYNAMIC_ARRAY *array, void *element);
 #define dynamic_array_ptr(array,array_index) ((array)->buffer+(array_index)*(array)->size_of_element)
 #define dynamic_element(array,array_index,type) ((type)((array)->buffer) +(array_index))
 #define push_dynamic(A,B) insert_dynamic((A),(B))
 #define reset_dynamic(array) ((array)->elements= 0)
 #define sort_dynamic(A,cmp) my_qsort((A)->buffer, (A)->elements, (A)->size_of_element, (cmp))
 
 extern my_bool init_dynamic_string(DYNAMIC_STRING *str, const char *init_str,
 				   size_t init_alloc,size_t alloc_increment);
 extern my_bool dynstr_append(DYNAMIC_STRING *str, const char *append);
 my_bool dynstr_append_mem(DYNAMIC_STRING *str, const char *append,
 			  size_t length);
 extern my_bool dynstr_append_os_quoted(DYNAMIC_STRING *str, const char *append,
                                        ...);
 extern my_bool dynstr_append_quoted(DYNAMIC_STRING *str,
                                     const char *append, size_t len,
                                     char quote);
 extern my_bool dynstr_set(DYNAMIC_STRING *str, const char *init_str);
 extern my_bool dynstr_realloc(DYNAMIC_STRING *str, size_t additional_size);
 extern my_bool dynstr_trunc(DYNAMIC_STRING *str, size_t n);
 extern void dynstr_free(DYNAMIC_STRING *str);
 extern uint32 copy_and_convert_extended(char *to, uint32 to_length,
                                         CHARSET_INFO *to_cs,
                                         const char *from, uint32 from_length,
                                         CHARSET_INFO *from_cs, uint *errors);
 extern void dynstr_reassociate(DYNAMIC_STRING *str, char **res, size_t *length,
                                size_t *alloc_length);
 extern uint32 copy_and_convert_extended(char *to, uint32 to_length,
                                         CHARSET_INFO *to_cs,
                                         const char *from, uint32 from_length,
                                         CHARSET_INFO *from_cs, uint *errors);
 #ifdef HAVE_MLOCK
 extern void *my_malloc_lock(size_t length,myf flags);
 extern void my_free_lock(void *ptr);
 #else
 #define my_malloc_lock(A,B) my_malloc((A),(B))
 #define my_free_lock(A) my_free((A))
 #endif
 #define alloc_root_inited(A) ((A)->min_malloc != 0)
 #define ALLOC_ROOT_MIN_BLOCK_SIZE (MALLOC_OVERHEAD + sizeof(USED_MEM) + 8)
 #define clear_alloc_root(A) do { (A)->free= (A)->used= (A)->pre_alloc= 0; (A)->min_malloc=0;} while(0)
 extern void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,
 			    size_t pre_alloc_size, myf my_flags);
 extern void *alloc_root(MEM_ROOT *mem_root, size_t Size);
 extern void *multi_alloc_root(MEM_ROOT *mem_root, ...);
 extern void free_root(MEM_ROOT *root, myf MyFLAGS);
 extern void set_prealloc_root(MEM_ROOT *root, char *ptr);
 extern void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,
                                 size_t prealloc_size);
 extern char *strdup_root(MEM_ROOT *root,const char *str);
 static inline char *safe_strdup_root(MEM_ROOT *root, const char *str)
 {
   return str ? strdup_root(root, str) : 0;
 }
 extern char *strmake_root(MEM_ROOT *root,const char *str,size_t len);
 extern void *memdup_root(MEM_ROOT *root,const void *str, size_t len);
 extern my_bool my_compress(uchar *, size_t *, size_t *);
 extern my_bool my_uncompress(uchar *, size_t , size_t *);
 extern uchar *my_compress_alloc(const uchar *packet, size_t *len,
                                 size_t *complen);
 extern void *my_az_allocator(void *dummy, unsigned int items, unsigned int size);
 extern void my_az_free(void *dummy, void *address);
 extern int my_compress_buffer(uchar *dest, size_t *destLen,
                               const uchar *source, size_t sourceLen);
 extern int packfrm(const uchar *, size_t, uchar **, size_t *);
 extern int unpackfrm(uchar **, size_t *, const uchar *);
 
 extern ha_checksum my_checksum(ha_checksum crc, const uchar *mem,
                                size_t count);
 #ifndef DBUG_OFF
 extern void my_debug_put_break_here(void);
 #else
 #define my_debug_put_break_here() do {} while(0)
 #endif
 
 extern void my_sleep(ulong m_seconds);
 extern ulong crc32(ulong crc, const uchar *buf, uint len);
 extern uint my_set_max_open_files(uint files);
 void my_free_open_file_info(void);
 
 extern my_bool my_gethwaddr(uchar *to);
-extern int my_getncpus();
+extern int my_getncpus(void);
 
 #define HRTIME_RESOLUTION               1000000ULL  /* microseconds */
 typedef struct {ulonglong val;} my_hrtime_t;
-void my_time_init();
-extern my_hrtime_t my_hrtime();
+void my_time_init(void);
+extern my_hrtime_t my_hrtime(void);
 extern ulonglong my_interval_timer(void);
 extern ulonglong my_getcputime(void);
 
 #define microsecond_interval_timer()    (my_interval_timer()/1000)
 #define hrtime_to_time(X)               ((X).val/HRTIME_RESOLUTION)
 #define hrtime_from_time(X)             ((ulonglong)((X)*HRTIME_RESOLUTION))
 #define hrtime_to_double(X)             ((X).val/(double)HRTIME_RESOLUTION)
 #define hrtime_sec_part(X)              ((ulong)((X).val % HRTIME_RESOLUTION))
 #define my_time(X)                      hrtime_to_time(my_hrtime())
 
 #ifdef HAVE_SYS_MMAN_H
 #include <sys/mman.h>
 
 #ifndef MAP_NOSYNC
 #define MAP_NOSYNC      0
 #endif
 #ifndef MAP_NORESERVE
 #define MAP_NORESERVE 0         /* For irix and AIX */
 #endif
 
 #ifdef HAVE_MMAP64
 #define my_mmap(a,b,c,d,e,f)    mmap64(a,b,c,d,e,f)
 #else
 #define my_mmap(a,b,c,d,e,f)    mmap(a,b,c,d,e,f)
 #endif
 #define my_munmap(a,b)          munmap((a),(b))
 
 #else
 /* not a complete set of mmap() flags, but only those that nesessary */
 #define PROT_READ        1
 #define PROT_WRITE       2
 #define MAP_NORESERVE    0
 #define MAP_SHARED       0x0001
 #define MAP_PRIVATE      0x0002
 #define MAP_NOSYNC       0x0800
 #define MAP_FAILED       ((void *)-1)
 #define MS_SYNC          0x0000
 
 #define HAVE_MMAP
 void *my_mmap(void *, size_t, int, int, int, my_off_t);
 int my_munmap(void *, size_t);
 #endif
 
 /* my_getpagesize */
 #ifdef HAVE_GETPAGESIZE
 #define my_getpagesize()        getpagesize()
 #else
 int my_getpagesize(void);
 #endif
 
 int my_msync(int, void *, size_t, int);
 
 #define MY_UUID_SIZE 16
 #define MY_UUID_STRING_LENGTH (8+1+4+1+4+1+4+1+12)
 
 void my_uuid_init(ulong seed1, ulong seed2);
 void my_uuid(uchar *guid);
 void my_uuid2str(const uchar *guid, char *s);
-void my_uuid_end();
+void my_uuid_end(void);
 
 /* character sets */
 extern void my_charset_loader_init_mysys(MY_CHARSET_LOADER *loader);
 extern uint get_charset_number(const char *cs_name, uint cs_flags);
 extern uint get_collation_number(const char *name);
 extern const char *get_charset_name(uint cs_number);
 
 extern CHARSET_INFO *get_charset(uint cs_number, myf flags);
 extern CHARSET_INFO *get_charset_by_name(const char *cs_name, myf flags);
 extern CHARSET_INFO *my_collation_get_by_name(MY_CHARSET_LOADER *loader,
                                               const char *name, myf flags);
 extern CHARSET_INFO *get_charset_by_csname(const char *cs_name,
 					   uint cs_flags, myf my_flags);
 extern CHARSET_INFO *my_charset_get_by_name(MY_CHARSET_LOADER *loader,
                                             const char *name,
                                             uint cs_flags, myf my_flags);
 extern my_bool resolve_charset(const char *cs_name,
                                CHARSET_INFO *default_cs,
                                CHARSET_INFO **cs);
 extern my_bool resolve_collation(const char *cl_name,
                                  CHARSET_INFO *default_cl,
                                  CHARSET_INFO **cl);
 extern void free_charsets(void);
 extern char *get_charsets_dir(char *buf);
 extern my_bool my_charset_same(CHARSET_INFO *cs1, CHARSET_INFO *cs2);
 extern my_bool init_compiled_charsets(myf flags);
 extern void add_compiled_collation(struct charset_info_st *cs);
 extern size_t escape_string_for_mysql(CHARSET_INFO *charset_info,
                                       char *to, size_t to_length,
                                       const char *from, size_t length);
 #ifdef __WIN__
 #define BACKSLASH_MBTAIL
 /* File system character set */
 extern CHARSET_INFO *fs_character_set(void);
 #endif
 extern size_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,
                                       char *to, size_t to_length,
                                       const char *from, size_t length);
 
 extern void thd_increment_bytes_sent(ulong length);
 extern void thd_increment_bytes_received(ulong length);
 extern void thd_increment_net_big_packet_count(ulong length);
 
 #ifdef __WIN__
 extern my_bool have_tcpip;		/* Is set if tcpip is used */
 
 /* implemented in my_windac.c */
 
 int my_security_attr_create(SECURITY_ATTRIBUTES **psa, const char **perror,
                             DWORD owner_rights, DWORD everybody_rights);
 
 void my_security_attr_free(SECURITY_ATTRIBUTES *sa);
 
 /* implemented in my_conio.c */
 char* my_cgets(char *string, size_t clen, size_t* plen);
 
 #endif
 
 #include <mysql/psi/psi.h>
 
 #ifdef HAVE_PSI_INTERFACE
 extern MYSQL_PLUGIN_IMPORT struct PSI_bootstrap *PSI_hook;
 extern void set_psi_server(PSI *psi);
 void my_init_mysys_psi_keys(void);
 #endif
 
 struct st_mysql_file;
 extern struct st_mysql_file *mysql_stdin;
 C_MODE_END
 #endif /* _my_sys_h */
